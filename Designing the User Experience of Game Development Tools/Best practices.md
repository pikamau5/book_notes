See also:

# Best practices

* Familiar icons
* Consistent colors
* Legible contrast (parsec?)
* Use radio/checkboxes for appropriate things (& other [UX Guidelines](../undefined) )
* Familiarity = good
* Representation of user actions (?)

### Feedback
* What is the tool doing now?
* What just happened?
* How much time is left?
#### Feedback overload
* Check the user goal & mental model
#### Feed-forward
* Show what will happen before the user commits to the action (preview)

### Grouping
* Cart sort (ask user to group cards)
* Chunking info you need to remember

# Heuristic evaluation
* Visibility of system status
	* What is it doing right now?
* Match system & user mental model
* User control & freedom
	* Undo
	* Feed-forward
* Consistency & standards
	* Follow guidelines & patterns
* Error prevention
	* Prevent actions
	* Increase [Excise]([Excise](:/53a0ededbeef405cb4a1972cdde1d9ab))
* Recognition rather than recall
* Flexibility & efficiency of use
	* Frequent actions = shortcuts
* Aesthetic & minimalist design
	* Try to simplify first (see [UI complexity](../[BOOK]%20UX%20for%20Gamedev%20Tools/Complexity.md))
	* Then hierarchy + [Progressive disclosure](../[BOOK]%20UX%20for%20Gamedev%20Tools/Progressive%20disclosure.md)
* Help users recognize, diagnose & recover from errors
	* Simple clear error message
	* Suggest solution?
	* Help avoid user making the error in the first place
* Help + docs
	* Clear place for docs + help
	* ?-button

# Evaluating heuristics
* Go through task flow
* Include screenshot/etc + problem severity
* Follow up with [Testing](../[BOOK]%20UX%20for%20Gamedev%20Tools/User%20testing.md)